-- MIGRACIÓN: FORENSIC AUDIT LEDGER (TAMPER-PROOF)
-- Objetivo: Crear una cadena de custodia criptográfica para logs de auditoría.

-- 1. Tabla de Auditoría (Si no existe, la creamos robusta)
CREATE TABLE IF NOT EXISTS public.audit_ledger (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    actor_id UUID REFERENCES auth.users(id),
    action VARCHAR NOT NULL, -- e.g., 'LOGIN', 'UPDATE_ROUTE'
    entity VARCHAR NOT NULL, -- e.g., 'vehicles'
    entity_id VARCHAR,
    payload JSONB,           -- Datos del cambio
    prev_hash VARCHAR(64),   -- Hash de la fila anterior (SHA-256)
    curr_hash VARCHAR(64)    -- Hash de esta fila (SHA-256)
);

-- Indice para búsquedas rápidas
CREATE INDEX idx_audit_actor ON public.audit_ledger(actor_id);
CREATE INDEX idx_audit_action ON public.audit_ledger(action);

-- 2. Función para Calcular Hash
CREATE OR REPLACE FUNCTION public.calculate_ledger_hash()
RETURNS TRIGGER AS $$
DECLARE
    last_hash VARCHAR(64);
    payload_text TEXT;
BEGIN
    -- Obtener el último hash (Blockchain-like linking)
    SELECT curr_hash INTO last_hash FROM public.audit_ledger ORDER BY id DESC LIMIT 1;
    
    -- Si es el primer registro, hash semilla
    IF last_hash IS NULL THEN
        last_hash := 'GENESIS_BLOCK_CELLVI_2_0';
    END IF;

    -- Concatenar datos críticos
    payload_text := COALESCE(NEW.actor_id::text, '') || NEW.action || NEW.entity || COALESCE(NEW.payload::text, '') || last_hash;

    -- Calcular SHA-256
    NEW.prev_hash := last_hash;
    NEW.curr_hash := encode(digest(payload_text, 'sha256'), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 3. Trigger en Insert (Forensic Validation)
CREATE TRIGGER trg_ledger_hash
BEFORE INSERT ON public.audit_ledger
FOR EACH ROW
EXECUTE FUNCTION public.calculate_ledger_hash();

-- 4. Protección contra Modificaciones (WORM Absoluto)
CREATE TRIGGER trg_ledger_immutable
BEFORE UPDATE OR DELETE ON public.audit_ledger
FOR EACH ROW
EXECUTE FUNCTION public.conserve_history(); -- Reusamos la funcion WORM anterior

-- Habilitar extensión pgcrypto si no está
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
