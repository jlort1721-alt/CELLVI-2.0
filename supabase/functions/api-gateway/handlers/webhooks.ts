import { RouteHandler } from "../router.ts";
import { createErrorResponse, createSuccessResponse } from "../validation.ts";
import {
  parsePaginationParams,
  applyPagination,
  applySearch,
  createPaginatedResponse,
} from "../pagination.ts";
import { z } from "https://deno.land/x/zod@v3.22.4/mod.ts";

/**
 * Webhook Endpoint Handlers
 *
 * CRUD operations for webhook subscriptions
 */

// ============================================================================
// SCHEMAS
// ============================================================================

const CreateWebhookSchema = z.object({
  url: z.string().url().regex(/^https?:\/\//, "URL must be HTTP or HTTPS"),
  description: z.string().max(500).optional(),
  event_types: z.array(z.string().max(50)).min(1).max(20),
  active: z.boolean().optional().default(true),
  max_retries: z.number().int().min(0).max(10).optional().default(3),
  retry_delay_seconds: z.number().int().min(10).max(3600).optional().default(60),
}).strict();

const UpdateWebhookSchema = z.object({
  url: z.string().url().regex(/^https?:\/\//).optional(),
  description: z.string().max(500).optional(),
  event_types: z.array(z.string().max(50)).min(1).max(20).optional(),
  active: z.boolean().optional(),
  max_retries: z.number().int().min(0).max(10).optional(),
  retry_delay_seconds: z.number().int().min(10).max(3600).optional(),
}).strict();

// ============================================================================
// GET /webhooks - List webhook endpoints
// ============================================================================

export const listWebhooks: RouteHandler = async (req, params, context) => {
  const { supabase, tenantId, url } = context;

  try {
    const pagination = parsePaginationParams(url);

    let query = supabase
      .from("webhook_endpoints")
      .select("*", { count: "exact" })
      .eq("tenant_id", tenantId);

    query = applySearch(query, pagination.search, ["url", "description"]);
    query = applyPagination(query, pagination);

    const { data, error, count } = await query;

    if (error) {
      return createErrorResponse("Failed to fetch webhooks", 500, { details: error.message });
    }

    return new Response(
      JSON.stringify(createPaginatedResponse(data || [], count || 0, pagination)),
      { status: 200, headers: { "content-type": "application/json" } }
    );
  } catch (error) {
    return createErrorResponse("Internal server error", 500);
  }
};

// ============================================================================
// GET /webhooks/:id - Get single webhook
// ============================================================================

export const getWebhook: RouteHandler = async (req, params, context) => {
  const { supabase, tenantId } = context;
  const { id } = params;

  const { data: webhook, error } = await supabase
    .from("webhook_endpoints")
    .select("*")
    .eq("id", id)
    .eq("tenant_id", tenantId)
    .single();

  if (error || !webhook) {
    return createErrorResponse("Webhook not found", 404);
  }

  return createSuccessResponse(webhook, 200);
};

// ============================================================================
// POST /webhooks - Create webhook
// ============================================================================

export const createWebhook: RouteHandler = async (req, params, context) => {
  const { supabase, tenantId } = context;

  try {
    const rawBody = await req.json();
    const validationResult = CreateWebhookSchema.safeParse(rawBody);

    if (!validationResult.success) {
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          issues: validationResult.error.issues.map((issue: any) => ({
            path: issue.path.join("."),
            message: issue.message,
          })),
        }),
        { status: 400, headers: { "content-type": "application/json" } }
      );
    }

    const validatedData = validationResult.data;

    // Check for duplicate URL for this tenant
    const { data: existing } = await supabase
      .from("webhook_endpoints")
      .select("id")
      .eq("tenant_id", tenantId)
      .eq("url", validatedData.url)
      .single();

    if (existing) {
      return createErrorResponse("Webhook with this URL already exists", 409);
    }

    // Insert webhook (secret will be auto-generated by trigger)
    const { data: webhook, error: insertError } = await supabase
      .from("webhook_endpoints")
      .insert({
        ...validatedData,
        tenant_id: tenantId,
        created_at: new Date().toISOString(),
      })
      .select()
      .single();

    if (insertError) {
      return createErrorResponse("Failed to create webhook", 500, { details: insertError.message });
    }

    return createSuccessResponse(webhook, 201);
  } catch (error) {
    return createErrorResponse("Internal server error", 500);
  }
};

// ============================================================================
// PATCH /webhooks/:id - Update webhook
// ============================================================================

export const updateWebhook: RouteHandler = async (req, params, context) => {
  const { supabase, tenantId } = context;
  const { id } = params;

  try {
    const rawBody = await req.json();
    const validationResult = UpdateWebhookSchema.safeParse(rawBody);

    if (!validationResult.success) {
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          issues: validationResult.error.issues.map((issue: any) => ({
            path: issue.path.join("."),
            message: issue.message,
          })),
        }),
        { status: 400, headers: { "content-type": "application/json" } }
      );
    }

    const validatedData = validationResult.data;

    // Ensure tenant owns this webhook
    const { data: existing, error: fetchError } = await supabase
      .from("webhook_endpoints")
      .select("id")
      .eq("id", id)
      .eq("tenant_id", tenantId)
      .single();

    if (fetchError || !existing) {
      return createErrorResponse("Webhook not found", 404);
    }

    const { data: webhook, error: updateError } = await supabase
      .from("webhook_endpoints")
      .update({
        ...validatedData,
        updated_at: new Date().toISOString(),
      })
      .eq("id", id)
      .eq("tenant_id", tenantId)
      .select()
      .single();

    if (updateError) {
      return createErrorResponse("Failed to update webhook", 500, { details: updateError.message });
    }

    return createSuccessResponse(webhook, 200);
  } catch (error) {
    return createErrorResponse("Internal server error", 500);
  }
};

// ============================================================================
// DELETE /webhooks/:id - Delete webhook
// ============================================================================

export const deleteWebhook: RouteHandler = async (req, params, context) => {
  const { supabase, tenantId } = context;
  const { id } = params;

  const { data: existing, error: fetchError } = await supabase
    .from("webhook_endpoints")
    .select("id")
    .eq("id", id)
    .eq("tenant_id", tenantId)
    .single();

  if (fetchError || !existing) {
    return createErrorResponse("Webhook not found", 404);
  }

  const { error: deleteError } = await supabase
    .from("webhook_endpoints")
    .delete()
    .eq("id", id)
    .eq("tenant_id", tenantId);

  if (deleteError) {
    return createErrorResponse("Failed to delete webhook", 500, { details: deleteError.message });
  }

  return createSuccessResponse({ message: "Webhook deleted successfully" }, 200);
};

// ============================================================================
// GET /webhooks/:id/deliveries - List webhook deliveries
// ============================================================================

export const getWebhookDeliveries: RouteHandler = async (req, params, context) => {
  const { supabase, tenantId, url } = context;
  const { id } = params;

  try {
    const pagination = parsePaginationParams(url);

    // Verify webhook belongs to tenant
    const { data: webhook } = await supabase
      .from("webhook_endpoints")
      .select("id")
      .eq("id", id)
      .eq("tenant_id", tenantId)
      .single();

    if (!webhook) {
      return createErrorResponse("Webhook not found", 404);
    }

    let query = supabase
      .from("webhook_deliveries")
      .select("*, event:webhook_events(event_type, resource_type)", { count: "exact" })
      .eq("endpoint_id", id)
      .eq("tenant_id", tenantId);

    query = applyPagination(query, pagination);

    const { data, error, count } = await query;

    if (error) {
      return createErrorResponse("Failed to fetch deliveries", 500, { details: error.message });
    }

    return new Response(
      JSON.stringify(createPaginatedResponse(data || [], count || 0, pagination)),
      { status: 200, headers: { "content-type": "application/json" } }
    );
  } catch (error) {
    return createErrorResponse("Internal server error", 500);
  }
};
